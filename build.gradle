/**
 * Gradle script to generate PageSeeder emails from templates
 */
//apply plugin: 'java'

// Requires for XSLT transformations
import javax.xml.transform.stream.StreamResult
import javax.xml.transform.stream.StreamSource
import javax.xml.transform.TransformerFactory 
import javax.xml.transform.Transformer 
import javax.xml.transform.TransformerException

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'net.sf.saxon:Saxon-HE:9.6.0-7'
  }
}

repositories { 
  mavenCentral()
}

configurations { 
  xslt 
} 

dependencies { 
  xslt 'net.sf.saxon:Saxon-HE:9.6.0-7'
}

// Generates the list of message files
task run(group: 'emails', dependsOn: ['assembleHTMLEmails', 'assembleTextEmails']) {
  description = 'Generate and assemble all emails'
}

// Install on your local PageSeeder install
task installOnLocalPageSeeder(type: Copy, group: 'emails', dependsOn: 'prepareTemplates') {
  description = 'Copy the HTML templates to a local PageSeeder installation'
  from 'src/main/template/html'
  into "$localPageSeeder/webapp/WEB-INF/template/$localProject/Notification"
}

// Generates the list of message files
task assembleHTMLEmails(group: 'emails', type: JavaExec, dependsOn: 'generateHTMLEmails') {
  description = 'Assembles all the HTML emails into a single file'
  classpath = configurations.xslt
  main = 'net.sf.saxon.Transform'
  inputs.dir 'email/html'
  inputs.file 'src/main/xslt/html-assemble.xsl'
  outputs.file 'email/emails-html.html'
  def htmlEmailURI = file('email/html').toURI();
  args (
    '-s:src/main/xslt/html-assemble.xsl',
    '-xsl:src/main/xslt/html-assemble.xsl',
    "-o:email/emails-html.html",
    "from=$htmlEmailURI"
  )
}

// Generates the list of message files
task assembleTextEmails(group: 'emails', type: JavaExec, dependsOn: 'generateTextEmails') {
  description = 'Assembles all the text emails into a single file'
  classpath = configurations.xslt
  main = 'net.sf.saxon.Transform'
  inputs.dir 'email/text'
  inputs.file 'src/main/xslt/text-assemble.xsl'
  outputs.file 'email/emails-text.html'
  def textEmailURI = file('email/text').toURI();
  args (
    '-s:src/main/xslt/text-assemble.xsl',
    '-xsl:src/main/xslt/text-assemble.xsl',
    "-o:email/emails-text.html",
    "from=$textEmailURI"
  )
}

// Generate the HTML Emails
task generateHTMLEmails(group: 'emails', dependsOn: ['preprocessMessages', 'prepareTemplates']) {
  description = 'Generates all the HTML emails as separate files'
  inputs.file 'gradle.properties'
  inputs.dir 'src/main/template/html'
  outputs.file 'email/html'
  doLast {
    File templateDir = file('src/main/template/html');
    File messageDir = file("$buildDir/message/");
    File emailDir = file('email/html/');
    emailDir.mkdirs();
    Properties output = new Properties();
    output.setProperty("encoding",   "utf-8");
    output.setProperty("method",     "xhtml");
    output.setProperty("media-type", "application/html+xml");
    output.setProperty("doctype-public", "-//W3C//DTD XHTML 1.0 Strict//EN");
    output.setProperty("doctype-system", "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd");
    output.setProperty("indent",     "no");
    FileCollection messages = files { messageDir.listFiles() };
    templateDir.eachFileMatch(~/^[a-z-]+.xsl$/) { template ->
      String email = template.name.replace('.xsl', '');
      def xsl = new StreamSource(template);
      try {
        Transformer transformer = TransformerFactory.newInstance().newTransformer(xsl);
        transformer.outputProperties = output;
        messages.each { message ->
          if (message.name.startsWith(email)) {
            File f = new File(emailDir, message.name.replace('.xml', '.html'))
            println 'Processing ' + message.name + ' with ' + template.name + ' as '+f.name;
            def xmlInput = new StreamSource(message);
            def xmlOutput = new StreamResult(f);
            transformer.transform(xmlInput, xmlOutput);
          }
        }
      } catch (TransformerException ex) {
        println ex.getMessageAndLocation();
      }
    }
  }
}

// Generate the Text Emails
task generateTextEmails(group: 'emails', dependsOn: ['preprocessMessages', 'prepareTemplates']) {
  description = 'Generates all the text emails as separate files'
  inputs.file 'gradle.properties'
  inputs.dir 'src/main/template/text'
  outputs.file 'email/text'
  doLast {
    File templateDir = file('src/main/template/text');
    File messageDir = file("$buildDir/message/");
    File emailDir = file('email/text');
    emailDir.mkdirs();
    Properties output = new Properties();
    output.setProperty("encoding", "utf-8");
    output.setProperty("method",   "text");
    FileCollection messages = files { messageDir.listFiles() };
    templateDir.eachFileMatch(~/^[a-z-]+.xsl$/) { template ->
      String email = template.name.replace('-text.xsl', '');
      def xsl = new StreamSource(template);
      try {
	    Transformer transformer = TransformerFactory.newInstance().newTransformer(xsl);
	    transformer.outputProperties = output;
        messages.each { message ->
	      if (message.name.startsWith(email)) {
	        File f = new File(emailDir, message.name.replace('.xml', '.txt'))
	        println 'Processing ' + message.name + ' with ' + template.name + ' as '+f.name;
	        def xmlInput = new StreamSource(message);
	        def xmlOutput = new StreamResult(f);
	        transformer.transform(xmlInput, xmlOutput);
	      }
	    }
	  } catch (TransformerException ex) {
        println ex.getMessageAndLocation();
      }
    }
  }
}

// Preprocess the message files
task preprocessMessages(type: JavaExec) {
  classpath = configurations.xslt
  main = 'net.sf.saxon.Transform'
  inputs.file 'gradle.properties'
  inputs.dir 'src/main/message'
  outputs.file "$buildDir/message/"
  args (
    '-s:src/main/message/',
    '-xsl:src/main/xslt/preprocess.xsl',
    "-o:$buildDir/message/",
    "hosturl=$hostURL",
    "emaildomain=$emailDomain",
  )
  onlyIf {
    project.hasProperty('hostURL')
    project.hasProperty('emailDomain')
  }
  doFirst {
    file("$buildDir/message/").mkdirs();
  }
}

// Copy the default templates the first time
task prepareTemplates(type: Copy) {
  from 'src/main/defaults'
  into 'src/main/template'
  onlyIf {
    return !file('src/main/template/html').exists();
  }
}
